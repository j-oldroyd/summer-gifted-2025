# Created 2025-06-17 Tue 12:56
#+title: Cryptography
#+author: Jesse Oldroyd
Lectures for mathematics summer gifted program.
* <2025-06-16 Mon>
- Python code for substitution cipher:
#+begin_src python :results output :session yes :exports both
  import random

  letters = list('abcdefghijklmnopqrstuvwxyz')
  letters_cipher = letters.copy()
  random.shuffle(letters_cipher)

  encryption_key = {}
  decryption_key = {}
  for l1, l2 in zip(letters, letters_cipher):
      encryption_key[l1] = l2
      decryption_key[l2] = l1

  def substitution_encrypt(plaintext, encryption_key):
      plaintext = plaintext.lower()
      ciphertext = ""

      for letter in plaintext:
          if letter in encryption_key.keys():
              ciphertext += encryption_key[letter]
          else:
              ciphertext += letter

      return ciphertext

  def substitution_decrypt(ciphertext, decryption_key):
      ciphertext = ciphertext.lower()
      plaintext = ""

      for letter in ciphertext:
          if letter in decryption_key.keys():
              plaintext += decryption_key[letter]
          else:
              plaintext += letter

      return plaintext

  message = "This is my message."
  encrypted_message = substitution_encrypt(message, encryption_key)
  decrypted_message = substitution_decrypt(encrypted_message, decryption_key)

  print(f"Message: {message}")
  print(f"Ciphertext: {encrypted_message}")
  print(f"Plaintext: {decrypted_message}")
#+end_src

#+results: 
: Message: This is my message.
: Ciphertext: ifbk bk se sukkwxu.
: Plaintext: this is my message.


- [[https://pi.math.cornell.edu/~mec/2003-2004/cryptography/subs/frequencies.html][Frequency diagram]] for letters of the English language.

- *Example*: The following message has been encrypted using a substitution
  cipher: 'ykbk nk vbk, og pijlyvggcg, nktz qobaogov.'
  Decrypt this message.

  /Answer/: The frequency diagram above gives us some clues as to what each
  letter could represent.  In particular, since ~e~ is the most common letter
  of the English alphabet and ~g~ and ~k~ are frequent letters in the above
  message, we can try to replace either of these letters (but not both!) with
  ~e~:
  #+begin_src python :session yes :exports both
    ciphertext = 'ykbk nk vbk, og pijlyvggcg, nktz qobaogov'
    decrypt2 = {'k':'e'} # Try replacing k with e
    substitution_decrypt(ciphertext, decrypt2)
  #+end_src

  #+results: 
  : yebe ne vbe, og pijlyvggcg, netz qobaogov


  Since the first word becomes ~yebe~, we now look for a four-letter word in
  English that has an ~e~ in the second and last entries.  One example, after
  some trial and error, is ~here~.  So now we try replacing ~y~ with ~h~ and
  ~b~ with ~r~:
  #+begin_src python :session yes :exports both
    decrypt2['y'] = 'h'
    decrypt2['b'] = 'r'
    substitution_decrypt(ciphertext, decrypt2)
  #+end_src

  #+results: 
  : here ne vre, og pijlhvggcg, netz qoraogov


  Now the first phrase in this message looks like it could be "here we are",
  and so we continue with these substitutions:
  #+begin_src python :session yes :exports both
    decrypt2['n'] = 'w'
    decrypt2['v'] = 'a'
    substitution_decrypt(ciphertext, decrypt2)
  #+end_src

  #+results: 
  : here we are, og pijlhaggcg, wetz qoraogoa


  A natural word that follows the phrase "here we are" is "in", so once again
  we add those letters to our key:
  #+begin_src python :session yes :exports both
    decrypt2['o'] = 'i'
    decrypt2['g'] = 'n'
    substitution_decrypt(ciphertext, decrypt2)
  #+end_src

  #+results: 
  : here we are, in pijlhanncn, wetz qirainia


  A little bit more trial and error gives the (likely) decrypted message:
  "here we are, in Buckhannon, West Virginia".
* <2025-06-17 Tue>
A *Caesar cipher* is an ancient cryptographic technique that represents a
special case of the substitution cipher mentioned above.  Also called a
/shift cipher/, this cipher simply shifts each letter of the alphabet down by
a certain amount:
| a | b | c | d | e | f | g | h | i | j | k | l | m | n | o | p | q | r | s | t | u | v | w | x | y | z |
| d | e | f | g | h | i | j | k | l | m | n | o | p | q | r | s | t | u | v | w | x | y | z | a | b | c |

The above table is an example of a ~ROT3~ Caesar cipher since each letter was
shifted three letters along the alphabet.

*Example*: Use the ~ROT3~ cipher above to encrypt the message ~Picard is
    better than Kirk.~  What Caesar cipher is the decryption key for the ~ROT3~
 cipher?  You can use the application [[https://caesar-cipher.com/caesar-cipher-wheel][here]] to help you visualize the cipher.

*Example*: The Caesar cipher is also vulnerable to frequency analysis just
 like the substitution cipher is.  Using this, try to decrypt the following
 message encrypted using the Caesar cipher:
#+results: 
: xh pcndct tktc pqat id uxvjgt dji iwxh bthhpvt?  x'b cdi hjgt.


Part of the reason the Caesar cipher is so easy to crack, like any other
substitution cipher, is because there is a one-to-one correspondence between
letters before and after encryption.  One way to address this is to use a
combination of Caesar ciphers as in the Vigenere cipher.  Such a cipher
makes use of a table like the following to encrypt a message: [[https://en.wikipedia.org/wiki/Vigen%C3%A8re_cipher#/media/File:Vigen%C3%A8re_square_shading.svg][Vigenere
cipher]].

This encryption scheme involves first choosing a /keyword/ and then using
the keyword to determine the corresponding encryption.  For example, the
message ~I'M THE BEST AT USING MAKING SECRETS~ with the keyword ~CATS~ would
encrypt to ~KMMZGBXKCAMECKBFISYUTEMK~.  The encryption process works by
selecting a row of the above Vigenere table using an appropriate letter from
the keyword and a column using the corresponding letter of the plaintext to
produce the encrypted letter.  The decryption process works by choosing a
row of the table by using the keyword, following along the row until you hit
the ciphertext letter, and then using the column to determine the plaintext
letter.

*Example*: using the Vigenere cipher with the keyword ~BAD~, /encrypt/ the
 plaintext ~WHOYOUGONNACALL~ and /decrypt/ the ciphertext ~HOVFAKBWNT~.

The Vigenere cipher long had a reputation for being unbreakable without
knowing the keyword, but in the 19th century mathematicians developed
methods for analyzing this cipher using frequency analysis.  To get an idea
of how this analysis works, suppose that some message is encrypted with an
unknown keyword to get ~URCAFYBBIKVLURCAFYBBI~.  A segment of this coded
message is repeated, which suggests that this segment corresponds to the
same word or phrase in the original message.  The second segment starts $12$
positions after the first, and so the keyword or phrase must be either $1$,
$2$, $3$, $4$, $6$, or $12$ letters long.  Since $1$, $2$, and $3$ would be
very short (and therefore weak) keywords, one can assume that the keyword is
$4$ letters long.

Now suppose we also happen to learn that the words ~DONTKNOW~ were
transmitted in this message.  An interesting thing happens if we shift this
phrase by $4$ letters and then "subtract"  the shifted version from the
original: ~DONTKNOW-KNOW____~ becomes ~TBZX____~.  Why is this important?
Because the same sequence also shows up if we apply the same operation to
the ciphertext.  This means that the position of the ciphertext that
corresponds to ~TBZK~ in the difference must also be the location of the
word ~KNOW~.  If we subtract the word ~KNOW~ from its corresponding
ciphertext, we get the keyword used to encrypt the message.  And once we
know the keyword, we can decrypt the rest of the message.
