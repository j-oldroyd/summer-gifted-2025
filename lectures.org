#+TITLE: Summer Gifted Notes 2025
#+AUTHOR: Jesse Oldroyd

* Cryptography
  :PROPERTIES:
  :EXPORT_FILE_NAME: cryptography
  :END:
  Lectures for mathematics summer gifted program.
** <2025-06-16 Mon>
   - Python code for substitution cipher:
   #+begin_src python :results output :session yes :exports both
     import random

     letters = list('abcdefghijklmnopqrstuvwxyz')
     letters_cipher = letters.copy()
     random.shuffle(letters_cipher)

     encryption_key = {}
     decryption_key = {}
     for l1, l2 in zip(letters, letters_cipher):
         encryption_key[l1] = l2
         decryption_key[l2] = l1

     def substitution_encrypt(plaintext, encryption_key):
         plaintext = plaintext.lower()
         ciphertext = ""

         for letter in plaintext:
             if letter in encryption_key.keys():
                 ciphertext += encryption_key[letter]
             else:
                 ciphertext += letter

         return ciphertext

     def substitution_decrypt(ciphertext, decryption_key):
         ciphertext = ciphertext.lower()
         plaintext = ""

         for letter in ciphertext:
             if letter in decryption_key.keys():
                 plaintext += decryption_key[letter]
             else:
                 plaintext += letter

         return plaintext

     message = "This is my message."
     encrypted_message = substitution_encrypt(message, encryption_key)
     decrypted_message = substitution_decrypt(encrypted_message, decryption_key)

     print(f"Message: {message}")
     print(f"Ciphertext: {encrypted_message}")
     print(f"Plaintext: {decrypted_message}")
   #+end_src

   #+RESULTS:
   : Message: This is my message.
   : Ciphertext: fzty ty ce cxyypbx.
   : Plaintext: this is my message.

   - [[https://pi.math.cornell.edu/~mec/2003-2004/cryptography/subs/frequencies.html][Frequency diagram]] for letters of the English language.

   - *Example*: The following message has been encrypted using a substitution
     cipher: 'ykbk nk vbk, og pijlyvggcg, nktz qobaogov.'
     Decrypt this message.

     /Answer/: The frequency diagram above gives us some clues as to what each
     letter could represent.  In particular, since ~e~ is the most common letter
     of the English alphabet and ~g~ and ~k~ are frequent letters in the above
     message, we can try to replace either of these letters (but not both!) with
     ~e~:
     #+begin_src python :session yes :exports both
       ciphertext = 'ykbk nk vbk, og pijlyvggcg, nktz qobaogov'
       decrypt2 = {'k':'e'} # Try replacing k with e
       substitution_decrypt(ciphertext, decrypt2)
     #+end_src

     #+RESULTS:
     : yebe ne vbe, og pijlyvggcg, netz qobaogov

     Since the first word becomes ~yebe~, we now look for a four-letter word in
     English that has an ~e~ in the second and last entries.  One example, after
     some trial and error, is ~here~.  So now we try replacing ~y~ with ~h~ and
     ~b~ with ~r~:
     #+begin_src python :session yes :exports both
       decrypt2['y'] = 'h'
       decrypt2['b'] = 'r'
       substitution_decrypt(ciphertext, decrypt2)
     #+end_src

     #+RESULTS:
     : here ne vre, og pijlhvggcg, netz qoraogov

     Now the first phrase in this message looks like it could be "here we are",
     and so we continue with these substitutions:
     #+begin_src python :session yes :exports both
       decrypt2['n'] = 'w'
       decrypt2['v'] = 'a'
       substitution_decrypt(ciphertext, decrypt2)
     #+end_src

     #+RESULTS:
     : here we are, og pijlhaggcg, wetz qoraogoa

     A natural word that follows the phrase "here we are" is "in", so once again
     we add those letters to our key:
     #+begin_src python :session yes :exports both
       decrypt2['o'] = 'i'
       decrypt2['g'] = 'n'
       substitution_decrypt(ciphertext, decrypt2)
     #+end_src

     #+RESULTS:
     : here we are, in pijlhanncn, wetz qirainia

     A little bit more trial and error gives the (likely) decrypted message:
     "here we are, in Buckhannon, West Virginia".
** <2025-06-17 Tue>
   A *Caesar cipher* is an ancient cryptographic technique that represents a
   special case of the substitution cipher mentioned above.  Also called a
   /shift cipher/, this cipher simply shifts each letter of the alphabet down by
   a certain amount:
   | a | b | c | d | e | f | g | h | i | j | k | l | m | n | o | p | q | r | s | t | u | v | w | x | y | z |
   | d | e | f | g | h | i | j | k | l | m | n | o | p | q | r | s | t | u | v | w | x | y | z | a | b | c |

   The above table is an example of a ~ROT3~ Caesar cipher since each letter was
   shifted three letters along the alphabet.

   *Example*: Use the ~ROT3~ cipher above to encrypt the message ~Picard is
    better than Kirk.~  What Caesar cipher is the decryption key for the ~ROT3~
    cipher?  You can use the application [[https://caesar-cipher.com/caesar-cipher-wheel][here]] to help you visualize the cipher.

   *Example*: The Caesar cipher is also vulnerable to frequency analysis just
    like the substitution cipher is.  Using this, try to decrypt the following
    message encrypted using the Caesar cipher:
    #+begin_src python :results output :exports results
      letters = list('abcdefghijklmnopqrstuvwxyz')
      letters_rotated = []
      for j in range(26):
          new_letter_pos = (j+15)%26
          letters_rotated.append(letters[new_letter_pos])

      message = "Is anyone even able to figure out this message?  I'm not sure."

      encryption_key = {}
      decryption_key = {}
      for l1, l2 in zip(letters, letters_rotated):
          encryption_key[l1] = l2
          decryption_key[l2] = l1

      def substitution_encrypt(plaintext, encryption_key):
          plaintext = plaintext.lower()
          ciphertext = ""

          for letter in plaintext:
              if letter in encryption_key.keys():
                  ciphertext += encryption_key[letter]
              else:
                  ciphertext += letter

          return ciphertext

      def substitution_decrypt(ciphertext, decryption_key):
          ciphertext = ciphertext.lower()
          plaintext = ""

          for letter in ciphertext:
              if letter in decryption_key.keys():
                  plaintext += decryption_key[letter]
              else:
                  plaintext += letter

          return plaintext

      print(substitution_encrypt(message, encryption_key))
    #+end_src

    #+RESULTS:
    : xh pcndct tktc pqat id uxvjgt dji iwxh bthhpvt?  x'b cdi hjgt.

    Part of the reason the Caesar cipher is so easy to crack, like any other
    substitution cipher, is because there is a one-to-one correspondence between
    letters before and after encryption.  One way to address this is to use a
    combination of Caesar ciphers as in the Vigenere cipher.  Such a cipher
    makes use of a table like the following to encrypt a message: [[https://en.wikipedia.org/wiki/Vigen%C3%A8re_cipher#/media/File:Vigen%C3%A8re_square_shading.svg][Vigenere
    cipher]].

    This encryption scheme involves first choosing a /keyword/ and then using
    the keyword to determine the corresponding encryption.  For example, the
    message ~I'M THE BEST AT USING MAKING SECRETS~ with the keyword ~CATS~ would
    encrypt to ~KMMZGBXKCAMECKBFISYUTEMK~.  The encryption process works by
    selecting a row of the above Vigenere table using an appropriate letter from
    the keyword and a column using the corresponding letter of the plaintext to
    produce the encrypted letter.  The decryption process works by choosing a
    row of the table by using the keyword, following along the row until you hit
    the ciphertext letter, and then using the column to determine the plaintext
    letter.

    *Example*: using the Vigenere cipher with the keyword ~BAD~, /encrypt/ the
     plaintext ~WHOYOUGONNACALL~ and /decrypt/ the ciphertext ~HOVFAKBWNT~.

    The Vigenere cipher long had a reputation for being unbreakable without
    knowing the keyword, but in the 19th century mathematicians developed
    methods for analyzing this cipher using frequency analysis.  To get an idea
    of how this analysis works, suppose that some message is encrypted with an
    unknown keyword to get ~URCAFYBBIKVLURCAFYBBI~.  A segment of this coded
    message is repeated, which suggests that this segment corresponds to the
    same word or phrase in the original message.  The second segment starts $12$
    positions after the first, and so the keyword or phrase must be either $1$,
    $2$, $3$, $4$, $6$, or $12$ letters long.  Since $1$, $2$, and $3$ would be
    very short (and therefore weak) keywords, one can assume that the keyword is
    $4$ letters long.

    Now suppose we also happen to learn that the words ~DONTKNOW~ were
    transmitted in this message.  An interesting thing happens if we shift this
    phrase by $4$ letters and then "subtract"  the shifted version from the
    original: ~DONTKNOW-KNOW____~ becomes ~TBZX____~.  Why is this important?
    Because the same sequence also shows up if we apply the same operation to
    the ciphertext.  This means that the position of the ciphertext that
    corresponds to ~TBZK~ in the difference must also be the location of the
    word ~KNOW~.  If we subtract the word ~KNOW~ from its corresponding
    ciphertext, we get the keyword used to encrypt the message.  And once we
    know the keyword, we can decrypt the rest of the message.
** <2025-06-18 Wed>
   Suppose that Alice and Bob want to send a message to each other across a
   noisy room, but they don't want anyone else to be able to understand what the
   message says.  They are also unable to get close enough to each other to
   relay the message in person, so they must rely on /public-key cryptography/
   to securely relay their information.

   Public-key cryptography works by creating a *private key* and a *public key*
   for every individual.  If Alice wants to send a message to Bob, then she can
   encrypt the message using Bob's public key and send it along.  Once Bob
   receives the message, they can decrypt the message with their own private
   key.  A nice example of this process is outlined [[https://crypto.mste.illinois.edu/][here]], and an
   encryption/decryption app is located [[https://crypto.mste.illinois.edu/encryption][here]].

   Public-key cryptography relies on properties of prime numbers to work
   securely.  In particular, the fact that multiplication is quick and factoring
   is difficult (or at least seems to be difficult) is essential.  The RSA
   algorithm is the oldest and one of the most widely used public-key
   cryptosystems and has two components: /key generation/ and
   /encryption-decryption/.  For more, you can view Chapter 8 of [[https://cacr.uwaterloo.ca/hac/about/chap8.pdf][The Handbook of
   Applied Cryptography]].  For key generation for person $A$:
   1. Generate two distinct primes $p$ and $q$ that are roughly the same size.
      The larger they are, the harder your key will be to crack.
   2. Set $n = pq$ and $\phi = (p-1)(q-1)$.
   3. Select an integer $e_A$ between $1$ and $\phi$ such that the greatest
      common divisor of $e_A$ and $\phi$ is equal to $1$.
   4. Find the unique integer $d_A$ between $1$ and $\phi$ such that $d_Ae_A =
      1\mod\phi$.  Your public key is $(n, e_A)$ and your private key is $d_A$.
   To encrypt a message from person $A$ to person $B$:
   1. Person $A$ should obtain person $B$'s public key $(n, e_B)$.
   2. Now, $A$ should take their message (viewed as an integer $m$ in
      $\mathbb{Z}_n$) and compute $c = m^e_B\mod n$.  This represents the
      ciphertext of the plaintext message $m$ and is transmitted to person $B$.
   3. Finally, person $B$ can decrypt the message by raising it to their own
      secret key: $m = c^d_B \mod n$.

   *Example*: Create your own private and public keys using $p = 7121$ and $q =
    6577$.
   #+begin_src python :results output :export both
     p = 7121
     q = 6577

   #+end_src
* Discrete mathematics
  :PROPERTIES:
  :EXPORT_FILE_NAME: discrete
  :END:
  Lectures for computer science summer gifted program.
** <2025-06-16 Mon>
   - Consider the problem of counting all multiples of $3$ or $5$ located below
   $1000$.  We'd like to solve this with a computer, but first we need to
   translate this into a form our computer program (Python) can understand.
   Therefore, it's not a bad idea to follow the workflow below:
   1. If the problem is too complicated, try to solve a simpler version of the
      problem.  Try multiple versions until you're confident you have a strategy
      that will work in general.  In particular, you want to make sure your
      strategy can appropriate deal with any /edge cases/.
   2. Try writing down the exact steps of your solution in good detail.  You
      will need a concrete description of your solution (i.e., an *algorithm*)
      to implement in your program.
   3. Convert each step of your algorithm into an appropriate section of
      computer code.  If you find this difficult to do at a particular step, it
      might mean you need to break this step into several simpler steps.

   For the previous problem of counting multiples, here is one potential
   algorithm:
   1. Count all the multiples of $3$ that are below $1000$.  Call this number
      $n_1$.
   2. Count all the multiples of $5$ that are below $1000$.  Call this number
      $n_2$.
   3. Count all the multiples of $3$ and $5$ that are below $1000$.  Call this
      number $n_3$.
   4. Compute $n_1 + n_2 - n_3$.


   - For another problem (also taken from [[https://projecteuler.net/][Project Euler]]), define the value of
     the $n^\text{th}$ *Fibonacci number* by the equations

   $$F_0 = 1, F_1 = 2\text{ and } F_n = F_{n-1}+F_{n-2}.$$

   Find the sum of the *even-valued* Fibonacci numbers that
   do not exceed $4000000$.
** <2025-06-17 Tue>
   Number theory is the study of the set of natural numbers $\mathbb{N}$, which
   for us is just the set of nonnegative whole numbers.  Since the prime numbers
   are the "building blocks" of every positive integer, number theory pays
   special attention to these numbers and the related concept of /divisibility/.
   In particular, we say that $j$ *divides* $k$ if there is a whole number $m$
   such that $k = mj$.  For instance, $2\mid 4$ and $15\mid60$ but $8\nmid20$.

   We can use Python to check if one number divides another quite easily using
   the *modulo* operator ~%~:
   #+begin_src python :exports both :results yes
     4%2 # = 0 since 2 | 4
     60%15 # = 0 since 15 | 60%15
     20%8 # does NOT equal 0 since 8 does not divide 20
   #+end_src

   *Example*: What does the modulo operator represent?  For example, if ~n%4~
    evaluates to $3$ for some mystery number $n$, what does this tell us about
    $n$?

   *Example*: What are all of the possible values of ~n%4~?  What about ~n%6~?

   Arithmetic with the modulo operator is called *modular arithmetic*.  We
   denote the result of ~k%n~ with the notation $k\mod n$.

   *Example*: Find $9\mod 5$ and $4452 \mod  71$.

   *Example*: If $k$ is a number that is a multiple of $3$ (i.e., $3\mid k$),
    what is true about $k\mod 3$?  What about the sum of its digits modulo $3$?

   An important property of modular arithmetic is that it "respects" regular
   arithmetic: if $a+b=c$ then $(a+b)\mod n = c \mod n$.

   *Example*: Modular arithmetic has applications in diverse fields of
    mathematics and its applications.  One important example lies in /error
    correcting codes/.  For example, the ISBN-10 is a ten digit number that is
    used to identify a specific text.  However, this can't be any ten digit
    number as some structure is required to help with identification.  A certain
    (amazing) book has ISBN given by $0691175918$.  To check that this is a
    valid ISBN, we multiply each digit by a decreasing sequence starting at 10,
    and then check if the result is a multiple of $11$:
    #+begin_src python :results output :exports both
      # isbn = 0691175918

      checksum = 10*0 + 9*6 + 8*9 + 7*1 + 6*1 + 5*7 + 4*5 + 3*9 + 2*1 + 1*8
      print(checksum%11)
    #+end_src

    #+RESULTS:
    : 0

    *Example*: Is $0416522351$ a valid ISBN-10 number?

    *Example*: Suppose that a book has a partial ISBN-10 number given by
     $030654401?$, where the last digit is unreadable.  What must the last
     digit be?

    The value of $k\mod n$ can be found using the *division algorithm*, which
    is one of the oldest and most important algorithms in mathematics.

    *Example*: Implement the division algorithm in Python.  As an example of
    what your algorithm should be capable of, ~division(45322, 21)~ should
    return the following values for the quotient $q$ and remainder $r$:

    #+begin_src python :exports results :results output
      def division(m, n):
        if m%1 != 0 or n%1 != 0 or m < 0 or n < 0:
          raise ValueError('Please enter nonnegative integers!')
        else:
          q = 0
          r = m
          while r >= n:
            q = q+1
            r = m - q*n

          return q, r

      print(division(45322, 21))
    #+end_src

    #+RESULTS:
    : (2158, 4)

     Modular arithmetic is also useful when dealing with /cyclic/ quantities.

    *Example*: A video game puzzle involves rotating three concentric rings so
     that their platforms line up.  At the start of the puzzle, the platforms
     are pointing east.  To solve the puzzle, all the platforms must be pointing
     south.  If moving a ring moves its adjacent circles in the opposite
     direction by the same amount, what moves will solve the puzzle?

     *Answer*: The puzzle is equivalent to solving the system of equations given
      by

      $$-x-y=1, -x+y-z=1, -y+z=1$$

      over $\mathbb{Z}_4$, where $x$ is the number of moves required of the
      inner ring, $y$ the middle and $z$ the outer.  This can easily be done
      using Python:
     #+begin_src python :results none :exports none
       from sympy import solve, ZZ
       from sympy.abc import x, y, z

       print(solve([-x-y-1, -x+y-z-1, -y+z-1], [x,y,z]))
     #+end_src

    The Caesar cipher (and Vigenere cipher) is also an application of modular
    arithmetic.

    *Example*: Create a Python program that implements the Caesar cipher.  The
     program should be able to take a given string and a given rotation value
     and return the encrypted version of that string.

    *Example*: An *affine cipher* is a modified form of the Caesar cipher that
    makes use of multiplication as well as addition to shift letters around.
    These ciphers take the form $f(x) = ax + b \mod 26$ when using the English
    alphabet.  Modify your code from the last example to create an affine
    cipher.

    Modular arithmetic is also useful in the construction of *one-way
    functions*, which are tools to verify correctness or integrity of some
    transmission.  For example, a recipient can use a one-way function to verify
    that they have successfully decrypted a message without referring to the
    message itself.  A good one-way function should be easy to compute but very
    difficult to invert.

    *Example*: Create a one-way function $f(x)$ as follows: let $n = 894847$ and
     define $f(x) = x^3 \mod n$ for $x$ in $\mathbb{Z}_n$.  Use this function to
     determine which other group in class was given the same number as you.
